# Copyright (c) 2020-2024, RTE (http://www.rte-france.com)
# See AUTHORS.md
# All rights reserved.
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, you can obtain one at http://mozilla.org/MPL/2.0/.
# SPDX-License-Identifier: MPL-2.0
# This file is part of the deeac project.

import traceback
import re
from typing import List, Union, TYPE_CHECKING

if TYPE_CHECKING:
    from deeac.domain.models import GeneratorCluster, DynamicGenerator, Value
    from deeac.domain.models.omib import OMIB
    from deeac.domain.models.eeac_tree import EEACTreeNode


class DEEACException(Exception):
    """
    Generic type of Exception generated by this library.
    """
    pass


class DEEACExternalException(DEEACException):
    """
    Exception external to DEEAC mapped to a DEEAC exception for formatting.
    """
    def __init__(self, exception_type, exception_value, exception_traceback):
        """
        Initialization.

        :param exception_type: Type of exception.
        :param exception_value: Value of exception.
        :param exception_traceback: Traceback of exception.
        """
        self.exception_type = exception_type
        self.exception_value = exception_value
        self.exception_traceback = exception_traceback

    def __str__(self):
        """
        Return a string representation of the list of exceptions.
        """
        msg = f"An exception of type {self.exception_type.__qualname__} occured"
        value = str(self.exception_value)
        if value != "":
            msg = f": {msg}."
        if self.exception_traceback is not None:
            tb = traceback.format_tb(self.exception_traceback)[-1].strip().replace("\n", ":")
            tb = re.sub("\\s+", " ", tb)
            msg = f"{msg} - Traceback: {tb}."
        return msg


class DEEACExceptionList(DEEACException):
    """
    List of DEEAC exceptions.
    """

    def __init__(self, exceptions: List[DEEACException] = None):
        """
        Initialization.
        """
        self.exceptions = exceptions if exceptions is not None else []

    def __str__(self):
        """
        Return a string representation of the list of exceptions.
        """
        if len(self.exceptions) == 0:
            return super().__str__()
        elif len(self.exceptions) == 1:
            return str(self.exceptions[0])
        else:
            description = "\n".join([f"\t{e.__class__.__qualname__} : {e}" for e in self.exceptions])
            return f"{len(self.exceptions)} exception(s) were encountered:\n{description}"

    def append(self, exception: DEEACException):
        """
        Append an exception to the list.

        :param exception: The exception to append.
        """
        self.exceptions.append(exception)


class DEEACExceptionCollector:
    """
    Collector of exceptions.
    Gathers them in a list, and raise a DEEACExceptionList with these errors if a new unexpected error does not allow
    processing further.
    """
    def __init__(self):
        """
        Initialize the collector with an empty list.
        """
        self._exceptions: List[DEEACException] = list()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if exc_value is None:
            # No error observed
            return True
        # Catch exception
        if isinstance(exc_value, DEEACExceptionList):
            self._exceptions += exc_value.exceptions
        elif isinstance(exc_value, DEEACException):
            self._exceptions.append(exc_value)
        else:
            self._exceptions.append(DEEACExternalException(exc_type, exc_value, traceback))
        # Do not propagate exception
        return True

    def contains_exceptions(self) -> bool:
        """
        Determine if the collector contains one or several DEEACException.

        :return: True if some exceptions were collected.
        """
        return True if len(self._exceptions) > 0 else False

    def raise_for_exception(self):
        """
        Raise a DEEACExceptionList if DEEACException were collected.

        raise DEEACExceptionList if collector contains at least one DEEACException.
        """
        if len(self._exceptions) > 0:
            raise DEEACExceptionList(self._exceptions)

    def add(self, exception: DEEACException):
        """
        Add an exception to the collector.

        :param exception: The exception to add.
        """
        self._exceptions.append(exception)

    def reset(self):
        """
        Empty the list of exceptions.
        """
        self._exceptions.clear()


class UnitTypeException(DEEACException):
    """
    Exception raised when two unit types are not identical.
    """

    def __init__(self, first_unit: str, second_unit: str):
        """
        Initialization.

        :param first_unit: First unit.
        :param second_unit: Second unit.
        """
        self.first_unit = first_unit
        self.second_unit = second_unit

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"Units {self.first_unit} and {self.second_unit} are not of the same type."


class UnitScaleException(DEEACException):
    """
    Exception raised when a unit does not have any associated scale.
    """

    def __init__(self, unit: str):
        """
        Initialization.

        :param unit: Unit that does not have any scale.
        """
        self.unit = unit

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"Unit {self.unit} is not associated to any scale."


class UnitBaseException(DEEACException):
    """
    Exception raised when a base for per-unit conversion is not specified or is 0.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return "Base for per-unit conversions must be set and different from 0."


class ValueAddBaseException(DEEACException):
    """
    Exception raised when two values are added without having the same base.
    """

    def __init__(self, base1, base2):
        """
        Initialization.

        :param unit: Unit that does not have any scale.
        """
        self.base1 = base1
        self.base2 = base2

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"Bases {self.base1} and {self.base2} are not identical."


class PerUnitException(DEEACException):
    """
    Exception raised when a per-unit conversion is impossible due to a missing base.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return "Cannot convert into per-unit due to missing base."


class UnknownUnitException(DEEACException):
    """
    Exception raised when a unit is unknown.
    """

    def __init__(self, unit: str):
        """
        Initialization.

        :param unit: Unknown unit.
        """
        self.unit = unit

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"Unknown unit {self.unit}."


class ElementNotFoundException(DEEACException):
    """
    Exception raised when an element is not found.
    """

    def __init__(self, name: str, element_type: str):
        """
        Initialization.

        :param name: Element name.
        :param element_type: Type of the element.
        """
        self.name = name
        self.element_type = element_type

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"No element of type {self.element_type} associated to name {self.name}."
        )


class SimplifiedNetworkBreakerException(DEEACException):
    """
    Exception raised when a breaker is requested for a simplified network where buses are merged.
    """

    def __init__(self, first_bus_name: str, second_bus_name: str):
        """
        Initialization.

        :param first_bus_name: Name of the first bus of the expected breaker.
        :param second_bus_name: Name of the second bus of the expected breaker.
        """
        self.first_bus_name = first_bus_name
        self.second_bus_name = second_bus_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Cannot obtain breaker between buses {self.first_bus_name} and {self.second_bus_name} as network was "
            f"simplified."
        )


class CoupledBusesException(DEEACException):
    """
    Exception raised when a bus cannot be coupled to another bus.
    """

    def __init__(self, first_bus_name: str, second_bus_name: str):
        """
        Initialization.

        :param first_bus_name: Name of the first bus.
        :param second_bus_name: Name of the second bus that should be coupled to the first one.
        """
        self.first_bus_name = first_bus_name
        self.second_bus_name = second_bus_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Cannot couple bus with name {self.second_bus_name} to bus named {self.first_bus_name} due to "
            f"different or unset voltages (base voltage and/or voltage), or because one of the buses is representing a "
            f"generator internal voltage."
        )


class BusVoltageException(DEEACException):
    """
    Exception raised when the voltage of a bus is not specified.
    """

    def __init__(self, name: str):
        """
        Initialization.

        :param name: Bus name.
        """
        self.name = name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"No voltage (magnitude and/or angle) specified for bus {self.name}."
        )


class BusMatrixException(DEEACException):
    """
    Exception raised when a value can not be found in the bus matrix.
    """

    def __init__(self, first_bus_name: str, second_bus_name: str):
        """
        Initialization.

        :param first_bus_name: First bus name.
        :param second_bus_name: Second bus name.
        """
        self.first_bus_name = first_bus_name
        self.second_bus_name = second_bus_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"No value in the bus matrix associated to buses {self.first_bus_name} and {self.second_bus_name}."
        )


class ParallelException(DEEACException):
    """
    Exception raised when no element was found at given parallel ID.
    """

    def __init__(self, parallel_id: str, sending_bus_name: str, receiving_bus_name: str):
        """
        Initialization.

        :param parallel_id: Parallel ID at which the element had to be found.
        :param sending_bus_name: Sending bus.
        :param receiving_bus_name: Receiving bus.
        """
        self.parallel_id = parallel_id
        self.sending_bus_name = sending_bus_name
        self.receiving_bus_name = receiving_bus_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"No element found on the branch between buses {self.sending_bus_name} and {self.receiving_bus_name} at "
            f"parallel ID {self.parallel_id}."
        )


class BranchContentException(DEEACException):
    """
    Exception raised when a branch contains unknown or incompatible parallel elements (e.g. a breaker and a
    transformer).
    """

    def __init__(self, sending_bus_name: str, receiving_bus_name: str):
        """
        Initialization.

        :param sending_bus_name: Sending bus.
        :param receiving_bus_name: Receiving bus.
        """
        self.sending_bus_name = sending_bus_name
        self.receiving_bus_name = receiving_bus_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Branch between buses {self.sending_bus_name} and {self.receiving_bus_name} contains unknown or "
            f"incompatible types of parallel elements."
        )


class UnexpectedBranchElementException(DEEACException):
    """
    Exception raised when a branch element is not of the expected type.
    """

    def __init__(self, sending_bus_name: str, receiving_bus_name: str, parallel_id: str, type: str, expected_type: str):
        """
        Initialization.

        :param sending_bus_name: Sending bus.
        :param receiving_bus_name: Receiving bus.
        :param parallel_id: Parallel ID at which the element was found.
        :param type: Type of the element at the parallel ID.
        :param expected_type: Expected type of the element at the parallel ID.
        """
        self.sending_bus_name = sending_bus_name
        self.receiving_bus_name = receiving_bus_name
        self.parallel_id = parallel_id
        self.type = type
        self.expected_type = expected_type

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Element at parallel ID {self.parallel_id} on branch between buses {self.sending_bus_name} and "
            f"{self.receiving_bus_name} is of type {self.type} while type {self.expected_type} was expected."
        )


class LoadFlowException(DEEACException):
    """
    Exception raised when a load flow is incomplete.
    """

    def __init__(self, network_element_id: str, network_element_type):
        """
        Initialization.

        :param network_element_id: ID of the element that cannot be found in the load flow results.
        :param network_element_type: Type of the element that cannot be found.
        """
        self.network_element_id = network_element_id
        self.network_element_type = network_element_type

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Element {self.network_element_id} of type {self.network_element_type} cannot be found in load flow "
            f"results."
        )


class DisconnectedElementException(DEEACException):
    """
    Exception raised when an element is disconnected from the network.
    """

    def __init__(self, network_element_repr: str, network_element_type):
        """
        Initialization.

        :param network_element_repr: Representation of the disconnected element.
        :param network_element_type: Type of the disconnected element.
        """
        self.network_element_repr = network_element_repr
        self.network_element_type = network_element_type

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Element of type {self.network_element_type} is disconnected from the network and some of its properties "
            f"cannot be computed.\nElement content: {self.network_element_repr}."
        )


class TransformerImpedanceException(DEEACException):
    """
    Exception raised when the impedance of a transformer is unknown.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return "Transformer impedance is unknown."


class ZeroDirectTransientReactanceException(DEEACException):
    """
    Exception raised when the direct transient reactance of a generator is zero.
    """

    def __init__(self, generator_name: str):
        """
        Initialization.

        :param generator: Name of the generator with a direct transient reactance equal to 0.
        """
        self.generator_name = generator_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Generator {self.generator_name} has a direct transient reactance equal to 0."
        )


class UnknownRotorAngleException(DEEACException):
    """
    Exception raised when the rotor angle of a dynamic generator is unknown.
    """

    def __init__(self, generator_name: str, time: float):
        """
        Initialization.

        :param generator_name: Name of the dynamic generator.
        :param time: Time at which the rotor angle was requested.
        """
        self.generator_name = generator_name
        self.time = time

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Unknown rotor angle for dynamic generator {self.generator_name} at time t={self.time}s."
        )


class UnknownAngularSpeedException(DEEACException):
    """
    Exception raised when the angular speeed of a dynamic generator is unknown.
    """

    def __init__(self, generator_name: str, time: float):
        """
        Initialization.

        :param generator_name: Name of the dynamic generator.
        :param time: Time at which the speed was requested.
        """
        self.generator_name = generator_name
        self.time = time

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Unknown angular speed for dynamic generator {self.generator_name} at time t={self.time}s."
        )


class UnknownNetworkStateException(DEEACException):
    """
    Exception raised when the state of the network was unkown when computing the rotor angle of a dynamic generator.
    """

    def __init__(self, generator_name: str, time: float):
        """
        Initialization.

        :param generator_name: Name of the dynamic generator.
        :param time: Time at which the network state was requested.
        """
        self.generator_name = generator_name
        self.time = time

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Unknown network state for dynamic generator {self.generator_name} at time t={self.time}s."
        )


class PartialCenterOfAngleException(DEEACException):
    """
    Exception raised when the partial center of angle of a generator cluster cannot be computed due to a total
    inertia equal to 0.
    """

    def __init__(self, generator_cluster: 'GeneratorCluster'):
        """
        Initialization.

        :param generator_cluster: Cluster in which the error occurs.
        """
        self.generator_cluster = generator_cluster

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Cannot compute partial center of angle due to total inertia equal to 0 in the following generator "
            f"cluster: [{self.generator_cluster}]"
        )


class GeneratorClusterMemberException(DEEACException):
    """
    Exception raised when an operation is asked on a GeneratorCluster based on a generator that is not in this cluster.
    """

    def __init__(self, generator_cluster: 'GeneratorCluster', generator_name: str):
        """
        Initialization.

        :param generator_cluster: Cluster in which the error occurs.
        :param generator: Name of the generator that does not belong to the cluster.
        """
        self.generator_cluster = generator_cluster
        self.generator_name = generator_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Operation asked on a generator cluster based on a generator that does not belong to this cluster. "
            f"Generator: {self.generator_name} - Cluster: [{self.generator_cluster}]."
        )


class LineShortCircuitException(DEEACException):
    """
    Exception raised when the position of the lline short circuit 0 or 1 and corresponds to a bus sshort circuit.
    """

    def __init__(self, first_bus_name: str, second_bus_name: str):
        """
        Initialization.

        :param first_bus_name: Name of the first bus of the line.
        :param second_bus_name: Name of the second bus of the line.
        """
        self.first_bus_name = first_bus_name
        self.second_bus_name = second_bus_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Short circuit position for line between buses {self.first_bus_name} and {self.second_bus_name} cannot be "
            f"0 or 1 as it would correspond to a bus short circuit."
        )


class GeneratorInertiaException(DEEACException):
    """
    Exception raised when a generator has no inertia.
    """

    def __init__(self, generator_name: str):
        """
        Initialization.

        :param generator_name: Name of the generator that has no inertia.
        """
        self.generator_name = generator_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"Generator {self.generator_name} has no inertia."


class OMIBInertiaException(DEEACException):
    """
    Exception raised when the OMIB has no inertia.
    """

    def __init__(self, omib: 'OMIB'):
        """
        Initialization.

        :param omib: OMIB for which the error occurs.
        """
        self.omib = omib

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"OMIB has no inertia: Critical cluster=[{self.omib._critical_cluster}] Non-critical "
            f"cluster=[{self.omib._non_critical_cluster}]"
        )


class OMIBAngleShiftException(DEEACException):
    """
    Exception raised when the angle shift cannot be computed.
    """

    def __init__(self, omib: 'OMIB'):
        """
        Initialization.

        :param omib: OMIB for which the error occurs.
        """
        self.omib = omib

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Cannot compute OMIB angle shift due to divisor value equal to 0: Critical "
            f"cluster=[{self.omib._critical_cluster}] Non-critical cluster=[{self.omib._non_critical_cluster}]"
        )


class EmptyGeneratorClusterException(DEEACException):
    """
    Exception raised when a generator cluster is empty.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return "A cluster of generators cannot be empty."


class OMIBException(DEEACException):
    """
    Exception raised when the OMIB model cannot be computed.
    """

    def __init__(self, omib: 'OMIB', message: str):
        """
        Initialization.

        :param omib: OMIB for which the error occurs.
        :param message: Description of the error.
        """
        self.omib = omib
        self.message = message

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        critical_cluster = ", ".join([gen.name for gen in self.omib._critical_cluster.generators])
        mechanical_power = round(self.omib.mechanical_power, 3)
        return (
            f"An error occur when computing OMIB model: "
            f"Critical cluster=[{critical_cluster}], "
            f"OMIB mechanical power: {mechanical_power} p.u., "
            f"Message: {self.message}"
            )


class RotorAngleTimeException(DEEACException):
    """
    Exception raised when the root of the time associated to a rotor angle cannot be computed.
    """

    def __init__(self, rotor_angle: float):
        """
        Initialization.

        :param rotor_angle: Rotor angle to which the time should correspond.
        """
        self.rotor_angle = rotor_angle

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Could not compute the time associated to the rotor angle {self.rotor_angle} rad."
        )


class CompositeCriterionException(DEEACException):
    """
    Exception raised when a critical cluster cannot be identified based on the composite criterion due to multiple
    failures in the network.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            "The composite criterion does not allow the identification of the critical cluster in a network where "
            "multiple failures occured."
        )


class NetworkStateException(DEEACException):
    """
    Exception raised when a network state could not be computed due to missing events.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            "Cannot compute network states as no event was provided."
        )


class CriticalClustersIdentifierThresholdException(DEEACException):
    """
    Exception raised when the threshold of a critical clusters identifier is not between 0 and 1.
    """

    def __init__(self, threshold: float):
        """
        Initialization.

        :param threshold: The threshold for the identifier.
        """
        self.threshold = threshold

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"The threshold provided to a critical clusters identifier must be between 0 and 1 excluded. "
            f"Provided value: {self.threshold}"
        )


class CriticalClustersIdentifierInfiniteCriterionException(DEEACException):
    """
    Exception raised when a criterion is infinite.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return "One or several criterions of the critical clusters identifier are infinite."


class CriticalClustersIdentifierUnknownGeneratorsException(DEEACException):
    """
    Exception raised when one or several generators cannot be identified by the critical clusters identifier.
    """

    def __init__(self, generators: List['DynamicGenerator'], unknown_generator_names: List[str]):
        """
        Initialization.

        :param generators: Generators in the network.
        :param unknown_generator_names: List of the names of the generators that cannot be identified.
        """
        self.generators = generators
        self.unknown_generator_names = unknown_generator_names

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        generator_names = ", ".join([gen.name for gen in self.generators])
        unknown_generators = ", ".join(self.unknown_generator_names)
        return (
            f"The following generators cannot be identified by the critical clusters identifier: {unknown_generators}. "
            f"Generators in the network: {generator_names}."
        )


class CriticalClustersIdentifierClusterException(DEEACException):
    """
    Exception raised when a generator cluster is empty.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"No valid generator identified as candidate for being critical. "
            f"Check your EEAC parameters (for instance TSO customization)."
        )


class CriticalClusterSelectorException(DEEACException):
    """
    Exception raised when a critical cluster selector has an empty list as input.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return "Empty input list for critical cluster selector."


class EEACTreeNodeInputsException(DEEACException):
    """
    Exception raised when the right inputs were not provided to a tree node.
    """

    def __init__(self, node: 'EEACTreeNode'):
        """
        Initialization.

        :param node: Tree node.
        """
        self.node = node

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        if self.node.inputs is None:
            msg = "No inputs provided for"
        else:
            msg = "Invalid inputs received for"
        inputs = [input.value for input in self.node.input_types]
        expected_inputs = ", ".join(input for input in sorted(inputs))
        return f"{msg} node {self.node.complete_id}. Expected inputs: {expected_inputs}."


class EEACTreeNodeCancelledException(DEEACException):
    """
    Exception raised when a node cannot be run as it was cancelled.
    """

    def __init__(self, node: 'EEACTreeNode'):
        """
        Initialization.

        :param node: Tree node.
        """
        self.node = node

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"Node {self.node.complete_id} cannot be run as its execution was cancelled."


class EEACTreeLeafException(DEEACException):
    """
    Exception raised when a leaf node is not a terminal node.
    """

    def __init__(self, node: 'EEACTreeNode'):
        """
        Initialization.

        :param node: Unexpected terminal node.
        """
        self.node = node

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        node_type = type(self.node).__name__

        return (
            f"Node {self.node.complete_id} of type {node_type} cannot be a leaf of an EEAC execution "
            f"tree."
        )


class EEACTreeChildException(DEEACException):
    """
    Exception raised when a child cannot be a successor of its parent node in an EEAC execution tree.
    """

    def __init__(self, parent: 'EEACTreeNode', child: 'EEACTreeNode'):
        """
        Initialization.

        :param node: Unexpected terminal node.
        """
        self.parent = parent
        self.child = child

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        # Child
        child_type = type(self.child).__name__
        msg = f"Node {self.child.complete_id} of type {child_type} cannot be the child of"
        # Parent
        parent_type = type(self.parent).__name__
        return (
            f"{msg} node {self.parent.complete_id} of type {parent_type} in an EEAC execution tree."
        )


class EEACTreeNodeException(DEEACException):
    """
    Exception raised when a node cannot be found in the execution tree.
    """

    def __init__(self, node_id: Union[str, int]):
        """
        Initialization.

        :param node_id: Node ID.
        """
        self.node_id = node_id

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"Node with ID {self.node_id} cannot be found in EEAC execution tree."


class EEACTreeDuplicateIDException(DEEACException):
    """
    Exception raised when two nodes have the same ID in the execution tree.
    """

    def __init__(self, node_id: Union[str, int]):
        """
        Initialization.

        :param node_id: Node ID.
        """
        self.node_id = node_id

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"Two nodes have the same ID in the execution tree: {self.node_id}"


class EEACTreeNodeTypeException(DEEACException):
    """
    Exception raised when an EEAC tree node type is not recognized.
    """

    def __init__(self, node_id: Union[int, str], node_name: str, node_type: str):
        """
        Initialization.

        :param node_id: Node ID.
        :param node_name: Node name.
        :param node_type: Node type.
        """
        self.node_id = node_id
        self.node_name = node_name
        self.node_type = node_type

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        if self.node_name is not None:
            return f"Type {self.node_type} of node {self.node_id}_{self.node_name} is unknown."
        else:
            return f"Type {self.node_type} of node {self.node_id} is unknown."


class EEACNodeConfigurationException(DEEACException):
    """
    Exception raised when an EEAC node configuration is not valid.
    """

    def __init__(self, node_id: Union[int, str], node_name: str, configuration_type: str, node_type: str):
        """
        Initialization.

        :param node_id: Node ID.
        :param node_name: Node name.
        :param configuration_type: Invalid configuration type.
        :param node_type: Node type.
        """
        self.node_id = node_id
        self.node_name = node_name
        self.node_type = node_type
        self.configuration_type = configuration_type

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        if self.configuration_type is None:
            msg = "Empty configuration is not allowed "
        else:
            msg = f"Configuration of type {self.configuration_type} is invalid "
        if self.node_name is not None:
            return (
                f"{msg} for node {self.node_id}_{self.node_name} of type {self.node_type}."
            )
        else:
            return f"{msg} for node {self.node_id} of type {self.node_type}."


class EEACTreeNodeOutputsException(DEEACException):
    """
    Exception raised when outputs are requested while node was not run or encountered a problem.
    """

    def __init__(self, node: 'EEACTreeNode'):
        """
        Initialization.

        :param node: Tree node.
        """
        self.node = node

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Cannot provide output for node {self.node.complete_id}, probably due to an exception, or because it was "
            f"not run."
        )


class EEACCriticalClusterEvaluatorSequenceException(DEEACException):
    """
    Exception raised when outputs are requested while node was not run.
    """

    def __init__(self, node_id: Union[int, str], node_name: str):
        """
        Initialization.

        :param node_id: Node ID.
        :param node_name: Node name.
        """
        self.node_id = node_id
        self.node_name = node_name

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        node_id = self.node_id
        name = self.node_name
        msg = "Invalid evaluation sequence for node"
        if name is not None:
            msg = f"{msg} {node_id}_{name} of type CriticalClustersEvaluator."
        else:
            msg = f"{msg} {node_id} of type CriticalClustersEvaluator."
        return (
            f"{msg} First evaluation node must have a critical and non-critical clusters as inputs, while last node "
            f"should output EEAC results for a critical cluster."
        )


class EEACCriticalClusterNoResultsException(DEEACException):
    """
    Exception raised when critical cluster evaluator could not obtain any results.
    """

    def __init__(self, node: 'EEACTreeNode'):
        """
        Initialization.

        :param node: Tree node.
        """
        self.node = node

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            f"Node {self.node.complete_id} of type CriticalClustersEvaluator could not obtain any results for the "
            f"different cluster candidates."
        )


class PlotOutputDirectoryException(DEEACException):
    """
    Exception raised when a plot is asked but no output directory is specified.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return "Cannot generate graph as no output directory is specified."


class GeneratorTrajectoryUpdateTimeException(DEEACException):
    """
    Exception raised when the transition and/or last update times are not valid when computing generator trajectories.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return (
            "Cannot compute generator trajectory if transition time is equal to 0 or higher or equal to the last update"
            " time."
        )


class MultipleSlackBusException(DEEACException):
    """
    Exception raised when multiple buses are flagged as slack.
    """

    def __init__(self, slack_bus_names: List[str]):
        """
        Initialization.

        :param slack_bus_names: Names of the different slack buses.
        """
        self.slack_bus_names = slack_bus_names

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        buses = ", ".join(self.slack_bus_names)
        return f"Multiple buses flagged as slack in network : {buses}"


class NoSlackBusException(DEEACException):
    """
    Exception raised when no bus is flagged as slack.
    """

    def __str__(self):
        """
        Return a string representation of the exception.
        """
        return f"No bus flagged as slack in network"
